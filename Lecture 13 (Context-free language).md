# Context-Free Language 

e.g.

Expression: `a + b * c - d` 

!["tag1"][tag1]

In general, regular languages is insufficient for nested language structures
- loop
- expressions
- blocks 
- loops 
- functions 

Hence it is impossible to write a compiler using regular language 

We solve this using _Context-Free language_

We define a context-free language as follow 
```
expr = ID | expr op expr | ( expor ) 

op   = + | - | * | /


Example:
( a + b ) * c 
  ^   ^   ^
  |   |   |
 expr ..  op 
  |   |
  ID  ID
```

!["tag2"][tag2]


## A **context-free grammar** is a 4 tuple of <V, Σ, P, S> where 
- `V` is a finite set non-terminal symbols 
    - e.g. {expr, op}
- `Σ` is a finite set (alphabet) terminal symbols 
    - e.g. {ID, +, -, ⋆, /, (, )}
- `P` production rules 
    - e.g. { expr -> ID, expr -> expr op expor, expr -> (expr), op -> +, op -> - ...}
- `S ∈ V` is the start non-terminal
    - e.g. { s = expr }


## Convention 

```
a, b, c, d    ∈ Σ
A, B, C, D, S ∈ V 
W, X, Y, Z    ∈ Σ U V 
w, x, y, z    ∈ Σ⋆
α, β, γ       ∈ (Σ U V)⋆
```


## DEF: α A B => α γ β if (A -> γ) ∈ P 
E.g.
```
expr => expr op expr => ID op expr 
```


## DEF: α1 => αn if α1 => α2 => ... αn
E.g.
```
expor =>⋆ ID + ID 
```


## DEF: the _language generated by G_ = {V, Σ, P, S} is: {w ∈ Σ⋆ | s => ⋆w} 

## DEF: a language `L` is context-free if there exists a grammar `G` that generates `L` 

## DEF: a context-free grammar is __ambigious__ if it allows multiple parse trees for same input string 
E.g. 

!["tag3"][tag3]

- to specify language precisly, we want unambigious grammar 
- question: How do we prove a grammar is unambigious? 
- observe that our previous definition of grammar is ambigious 
- new definition 
```
expr -> term 
        | expr + term 
        | expr - term 
term -> ID | term * ID | term / ID 
```

Note: There is no algorithm to tell if two different grammar generates the same langauge (but sometimes provable)


# Parsing Algorithm 
- input: grammar `G`, string `w` 
- output: 
    - boolean: Does `S` =>⋆ `w` ? 
    - OR
    - generate derivation / parse tree 

Recall that:


## A **context-free grammar** is a 4 tuple of <V, Σ, P, S> where 
- `V` is a finite set non-terminal symbols 
    - e.g. {expr, op}
- `Σ` is a finite set (alphabet) terminal symbols 
    - e.g. {ID, +, -, ⋆, /, (, )}
- `P` production rules 
    - e.g. { expr -> ID, expr -> expr op expor, expr -> (expr), op -> +, op -> - ...}
- `S ∈ V` is the start non-terminal
    - e.g. { s = expr }


## Convention 

```
a, b, c, d    ∈ Σ
A, B, C, D, S ∈ V 
W, X, Y, Z    ∈ Σ U V 
w, x, y, z    ∈ Σ⋆
α, β, γ       ∈ (Σ U V)⋆
```


``` Psuedo Code 
parse(α, x): Boolean or Option[Seq[Tree]] =  // does α =>⋆ x ?
{
    if(α.isEmpty) {
        if(x.isEmpty) return true                                                                  // Seq()
        else return false
    } else if(α == aβ) {
        if(x@(a :: z) && parse(β, z)) return true // a is the terminal term of α, then parse(β, z) // a +: parse(β, z)   
        else return false 
    } else if(α == A) {                                                                            //     A 
        foreach(A->γ ∈ P) {                                                                        //    /|\
            if(parse(γ, x)) return true                                                            // parse(γ, x)
        }
        return false 
    } else { // α = Aβ, β is nonempty
        foreach(split x = x1 x2) { // split x in all possible ways                               // parse(A, x1) ++ parse(β, x2)
            if(parse(A, x1) && parse(β, x2)) return true                                           
        }                                                                                          
        return false 
    }
}
```



E.g. 
```
p( expr =>⋆ ID + ID )
  // expr -> ID
  p( ID =>⋆ ID + ID )
    p( ε =>⋆ + ID ) // false 

  // 4th case 
  // expr => expr op expr
  p( expr op expr => ID + ID) 
   
    // split as: ε, ID + ID 
    // 3rd case 
    p(expr =>⋆ ε)
    | // expr -> ID 
    | p(ID =>⋆ ε) // false, ID does not derive empty string 
    |
    | // expr -> expr op expr 
    | // 4th case again 
    | p(expr op expr =>⋆ ε)
    |   // split ε = ε, ε
    |   p(expr =>⋆ ε) // false (now we memorize the result this case to avoid infinite recursion )
    |>>>> false 

    // split as: ID, + ID 
    p( expr =>⋆ ID )

      // expr -> ID 
      p( ID =>⋆ ID )

        p( ε => ⋆ ε ) // true 

      // 4th case 
      p( op expr =>⋆ + ID)
      // ...
      // ...
      // ...

```


## Runtime for parsing algorithm 
- infinite or expential on some grammar 
- what are the all possible values of `α` and `x`
  - `α = S` or `α` is suffix of a R.H.S of some production rule 
  - `x` string of terminal symbols 
    - always a substring of the input   
- number of possible values:
  - α: O(1) for any given grammar 
  - from:   O(|w|) O(size of input)
  - length: O(|w|)

## Memoization table: 
``` Scala
val memo = Map[(Seq[Symbol], Int, Int), Option[Seq[Tree]]]
//              alpha       from   length
// 1. Whenever parse/recur returns, save the return value in memo table 
// 2. At beginning of recur, check whether memo table already has result 
// 3. Just before starting the computation in recur, if the result is not being set already, set memo(α, x) = None 
```

### Complexity
- O(|w|^2) space
- O(|w|^3) time 


### To instead of return true/false, we can use the memorization table to implement construction of parse tree 


## Other parsing algorithm (for context)
- CYK 
  - O(|w|^3) time O(|w|^2) space 
  - 0.5 week
  - works with all grammar
  - no correct prefix property 
- Earley
  - O(|w|^3) for ambigious grammar 
  - O(|w|^2) for unambigious grammar
  - O(|w|)   for most of LR(K) grammar
  - 1.5 weeks 
  - correct prefix property 
- LR(1) / LR(K)
  - O(|w|) time / space 
  - 3 weeks in CS 444
  - works with unambigious practical grammars
  - correct prefix property 
- LL(1) / LL(K)
  - 1.5 weeks 
  - O(|w|) time / space 
  - few practical grammars 
  - cannot build left-associative parse tree 
    - e.g. `3 - 2 - 1` cannot be parsed 
  - correct prefix property 

### Definition: 
- Let `w` = `xaz` ∉ `L` be some incorrect string, 
- ∃`y` s.t. `x`, `y` ∈ `L` is a valid input 
- ∀`v` `x``a``v` ∉ `L`
- A parser has the __correct prefix property__ if it rejects the input when it encounters `a` 


## Compiler:

```
Sequence of chars -> |scanner A7| -> |parser| -> | ??? |  -> |code generation| -> machine language
                                  ^           ^            ^
                                  tokens     parse tree    code tree 
```

### `???` - is the __context-sensitive analysis__ or __semantic analysis__ (A9)
- rejects programs that satisfy grammar but are still wrong 
- computes information needed to generate code 

### In Lacs 
- need two things 
  1. resolving name 
    - map each `ID` to a specific variable or procedure 
    - build symbol table for each scope (procedure)
      - detect undelcared variables / names 
      - detect duplicate 
  2. compute and check types 



[tag1]: https://imagehosting-50cd6.firebaseapp.com/l13tag1.JPG "tag1"
[tag2]: https://imagehosting-50cd6.firebaseapp.com/l13tag2.JPG "tag2"
[tag3]: https://imagehosting-50cd6.firebaseapp.com/l13tag3.JPG "tag3"




